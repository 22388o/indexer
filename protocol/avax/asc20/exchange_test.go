// Copyright (c) 2023-2024 The UXUY Developer Team
// License:
// MIT License

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//SOFTWARE

package asc20

import (
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/shopspring/decimal"
	"github.com/sirupsen/logrus"
	"github.com/stretchr/testify/assert"
	"github.com/uxuycom/indexer/client/xycommon"
	"github.com/uxuycom/indexer/dcache"
	"github.com/uxuycom/indexer/devents"
	"github.com/uxuycom/indexer/xylog"
	"math/big"
	"testing"
)

func init() {
	xylog.InitLog(logrus.DebugLevel, "")
}

type ASC20OrderFullArgs struct {
	Seller         common.Address
	Creator        common.Address
	ListId         [32]byte
	Ticker         string
	Amount         *big.Int
	Price          *big.Int
	Nonce          *big.Int
	ListingTime    uint64
	ExpirationTime uint64
	CreatorFeeRate uint16
	Salt           uint32
	ExtraParams    []byte
	V              uint8
	R              [32]byte
	S              [32]byte
}

func TestExtractInputOrders_cancelOrdersVerify(t *testing.T) {
	orders := []ASC20OrderFullArgs{
		{
			ListId: [32]byte{80, 207, 14, 84, 56, 53, 76, 69, 188, 175, 22, 137, 145, 106, 106, 227, 154, 33, 152, 5, 144, 69, 187, 121, 39, 92, 113, 141, 79, 206, 122, 93},
			Ticker: "avax",
			Amount: big.NewInt(15000000000),
			Price:  big.NewInt(1),
			Nonce:  big.NewInt(1),
		},

		{
			ListId: [32]byte{220, 241, 188, 148, 43, 177, 88, 166, 105, 230, 206, 75, 248, 113, 76, 6, 170, 175, 25, 171, 189, 150, 192, 143, 94, 117, 159, 156, 166, 150, 253, 168},
			Ticker: "avav",
			Amount: big.NewInt(16000000000),
			Price:  big.NewInt(1),
			Nonce:  big.NewInt(1),
		},
		{
			ListId: [32]byte{132, 182, 240, 189, 68, 171, 168, 200, 126, 65, 108, 145, 224, 135, 74, 107, 29, 74, 75, 158, 178, 58, 122, 236, 106, 147, 134, 14, 62, 25, 222, 213},
			Ticker: "xxyy",
			Amount: big.NewInt(18000000000),
			Price:  big.NewInt(1),
			Nonce:  big.NewInt(1),
		},
	}

	cache := dcache.NewManager(nil, "avax")
	protocol := NewProtocol(cache)

	results := protocol.extractInputOrders("", "0x7b2c304d00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000002a000000000000000000000000000000000000000000000000000000000000004e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000050cf0e5438354c45bcaf1689916a6ae39a2198059045bb79275c718d4fce7a5d00000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000037e11d600000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000022000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000046176617800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000dcf1bc942bb158a669e6ce4bf8714c06aaaf19abbd96c08f5e759f9ca696fda800000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000003b9aca00000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004617661760000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000084b6f0bd44aba8c87e416c91e0874a6b1d4a4b9eb23a7aec6a93860e3e19ded500000000000000000000000000000000000000000000000000000000000001e00000000000000000000000000000000000000000000000000000000430e234000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000220000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000478787979000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000")

	assert.Equal(t, len(results), len(orders))

	if len(results) != len(orders) {
		for _, order := range orders {
			result, ok := results[common.BytesToHash(order.ListId[:]).String()]
			assert.NotNil(t, result)
			if ok {
				assert.Equal(t, result.Ticker, order.Ticker)
				assert.Equal(t, result.Amount.String(), order.Amount.String())
			}
		}
	}
}

func TestExtractInputOrders_batchMatchOrdersVerify(t *testing.T) {
	orders := []ASC20OrderFullArgs{
		{
			ListId: [32]byte{80, 207, 14, 84, 56, 53, 76, 69, 188, 175, 22, 137, 145, 106, 106, 227, 154, 33, 152, 5, 144, 69, 187, 121, 39, 92, 113, 141, 79, 206, 122, 93},
			Ticker: "avax",
			Amount: big.NewInt(15000000000),
			Price:  big.NewInt(1),
			Nonce:  big.NewInt(1),
		},

		{
			ListId: [32]byte{220, 241, 188, 148, 43, 177, 88, 166, 105, 230, 206, 75, 248, 113, 76, 6, 170, 175, 25, 171, 189, 150, 192, 143, 94, 117, 159, 156, 166, 150, 253, 168},
			Ticker: "avav",
			Amount: big.NewInt(16000000000),
			Price:  big.NewInt(1),
			Nonce:  big.NewInt(1),
		},
		{
			ListId: [32]byte{132, 182, 240, 189, 68, 171, 168, 200, 126, 65, 108, 145, 224, 135, 74, 107, 29, 74, 75, 158, 178, 58, 122, 236, 106, 147, 134, 14, 62, 25, 222, 213},
			Ticker: "xxyy",
			Amount: big.NewInt(18000000000),
			Price:  big.NewInt(1),
			Nonce:  big.NewInt(1),
		},
	}

	cache := dcache.NewManager(nil, "avax")
	protocol := NewProtocol(cache)

	results := protocol.extractInputOrders("", "0x24608215000000000000000000000000000000000000000000000000000000000000004000000000000000000000000024e24277e2ff8828d5d2e278764ca258c22bd4970000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000002a000000000000000000000000000000000000000000000000000000000000004e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000050cf0e5438354c45bcaf1689916a6ae39a2198059045bb79275c718d4fce7a5d00000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000037e11d600000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000022000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000046176617800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000dcf1bc942bb158a669e6ce4bf8714c06aaaf19abbd96c08f5e759f9ca696fda800000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000003b9aca00000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004617661760000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000084b6f0bd44aba8c87e416c91e0874a6b1d4a4b9eb23a7aec6a93860e3e19ded500000000000000000000000000000000000000000000000000000000000001e00000000000000000000000000000000000000000000000000000000430e234000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000220000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000478787979000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000")

	assert.Equal(t, len(results), len(orders))

	if len(results) != len(orders) {
		for _, order := range orders {
			result, ok := results[common.BytesToHash(order.ListId[:]).String()]
			assert.NotNil(t, result)
			if ok {
				assert.Equal(t, result.Ticker, order.Ticker)
				assert.Equal(t, result.Amount.String(), order.Amount.String())
			}
		}
	}
}

func TestExtractInputOrders_buildPackData(t *testing.T) {
	orders := []ASC20OrderFullArgs{
		{
			ListId: [32]byte{80, 207, 14, 84, 56, 53, 76, 69, 188, 175, 22, 137, 145, 106, 106, 227, 154, 33, 152, 5, 144, 69, 187, 121, 39, 92, 113, 141, 79, 206, 122, 93},
			Ticker: "avax",
			Amount: big.NewInt(15000000000),
			Price:  big.NewInt(1),
			Nonce:  big.NewInt(1),
		},

		{
			ListId: [32]byte{220, 241, 188, 148, 43, 177, 88, 166, 105, 230, 206, 75, 248, 113, 76, 6, 170, 175, 25, 171, 189, 150, 192, 143, 94, 117, 159, 156, 166, 150, 253, 168},
			Ticker: "avav",
			Amount: big.NewInt(16000000000),
			Price:  big.NewInt(1),
			Nonce:  big.NewInt(1),
		},
		{
			ListId: [32]byte{132, 182, 240, 189, 68, 171, 168, 200, 126, 65, 108, 145, 224, 135, 74, 107, 29, 74, 75, 158, 178, 58, 122, 236, 106, 147, 134, 14, 62, 25, 222, 213},
			Ticker: "xxyy",
			Amount: big.NewInt(18000000000),
			Price:  big.NewInt(1),
			Nonce:  big.NewInt(1),
		},
	}
	method, ok := ParsedABI.Methods["batchMatchOrders"]
	if !ok {
		t.Logf("not found method batchMatchOrders")
		return
	}

	to := common.HexToAddress("0x24e24277e2FF8828d5d2e278764CA258C22BD497")

	data, err := method.Inputs.PackValues([]interface{}{orders, to})
	if err != nil {
		t.Logf("pack error:%v", err)
		return
	}

	callData := append(method.ID, data...)

	//t.Logf("data: 0x%s", common.Bytes2Hex(callData))
	assert.NotEmpty(t, callData)
}

func TestExtractValidOrdersByExchange(t *testing.T) {
	tests := []struct {
		Name     string
		Tx       *xycommon.RpcTransaction
		Expected []*Exchange
	}{
		{
			Name: "extractValidOrdersByExchange_executeOrder",
			Tx: &xycommon.RpcTransaction{
				Input: "0xd9b3d6d00000000000000000000000000000000000000000000000000000000000000040000000000000000000000000eb23c2ed8eba5bf14ed56db47613177c6ecbbcf900000000000000000000000047b83879dce8d84ee4bb6d6df092ed00834ab98100000000000000000000000024e24277e2ff8828d5d2e278764ca258c22bd497dd6d2d461eb654a4c46d792d28562a610c121d8e4f016aa17a77fde77d2bf98500000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000037e11d60000000000000000000000000000000000000000000000000000000000321d531900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000065a3f9a20000000000000000000000000000000000000000000000000000000065cb86a200000000000000000000000000000000000000000000000000000000000000c800000000000000000000000000000000000000000000000000000000345054090000000000000000000000000000000000000000000000000000000000000220000000000000000000000000000000000000000000000000000000000000001bb7261b10aabe1fb9d938578a9fbb964bc3921d4dcbf5252f2517da2d3fe48975568dc828b4404d0ca56cc6d4ab7aa140b66ff6c78cc3f2d07831d8ec55b5f43d0000000000000000000000000000000000000000000000000000000000000004617661760000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000",
				Events: []xycommon.RpcLog{
					{
						Address: common.HexToAddress("0x24e24277e2FF8828d5d2e278764CA258C22BD497"),
						Topics: []common.Hash{
							common.HexToHash("0xe2750d6418e3719830794d3db788aa72febcd657bcd18ed8f1facdbf61a69a9a"),
							common.HexToHash("0x00000000000000000000000047b83879dce8d84ee4bb6d6df092ed00834ab981"),
							common.HexToHash("0x000000000000000000000000eb23c2ed8eba5bf14ed56db47613177c6ecbbcf9"),
						},
						Data: hexutil.MustDecode("0xdd6d2d461eb654a4c46d792d28562a610c121d8e4f016aa17a77fde77d2bf985"),
					},
				},
			},
			Expected: []*Exchange{
				{
					Tick:    "avav",
					From:    "0x24e24277e2FF8828d5d2e278764CA258C22BD497",
					To:      "0xEB23C2eD8eBa5BF14eD56db47613177C6eCBbCF9",
					Amount:  decimal.NewFromInt(15000000000),
					Operate: devents.OperateExchange,
				},
			},
		},
		{
			Name: "extractValidOrdersByExchange_cancelOrder",
			Tx: &xycommon.RpcTransaction{
				Input: "0xa3e37b4f0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000a6dc0352f4929c471247a872446b63a82dc14ff800000000000000000000000024e24277e2ff8828d5d2e278764ca258c22bd49750cf0e5438354c45bcaf1689916a6ae39a2198059045bb79275c718d4fce7a5d00000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000015e84151f60000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000659ad32a00000000000000000000000000000000000000000000000000000000659babcc00000000000000000000000000000000000000000000000000000000000000c800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000220000000000000000000000000000000000000000000000000000000000000001b720c7645a0cf66c32716098b152467879fca2d7f8bedf0f8e2840953983c4b4203f9992734635c9dccf17e544b01de9485a9358b97bd21a4b84134c48c867cda000000000000000000000000000000000000000000000000000000000000000461766176000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
				Events: []xycommon.RpcLog{
					{
						Address: common.HexToAddress("0x24e24277e2FF8828d5d2e278764CA258C22BD497"),
						Topics: []common.Hash{
							common.HexToHash("0xe2750d6418e3719830794d3db788aa72febcd657bcd18ed8f1facdbf61a69a9a"),
							common.HexToHash("0x000000000000000000000000a6dc0352f4929c471247a872446b63a82dc14ff8"),
							common.HexToHash("0x000000000000000000000000a6dc0352f4929c471247a872446b63a82dc14ff8"),
						},
						Data: hexutil.MustDecode("0x50cf0e5438354c45bcaf1689916a6ae39a2198059045bb79275c718d4fce7a5d"),
					},
				},
			},
			Expected: []*Exchange{
				{
					Tick:    "avav",
					From:    "0x24e24277e2FF8828d5d2e278764CA258C22BD497",
					To:      "0xa6DC0352F4929c471247a872446B63a82dc14Ff8",
					Amount:  decimal.NewFromInt(94090908150),
					Operate: devents.OperateDelist,
				},
			},
		},
		{
			Name: "extractValidOrdersByExchange_failed",
			Tx: &xycommon.RpcTransaction{
				Events: []xycommon.RpcLog{
					{
						Address: common.HexToAddress("0x24e24277e2FF8828d5d2e278764CA258C22BD497"),
						Topics: []common.Hash{
							common.HexToHash("0xe2750d6418e3719830794d3db788aa72febcd657bcd18ed8f1facdbf61a69a9a"),
							common.HexToHash("0x00000000000000000000000023b2a8e35deea93139abc2791e895c65e1aa4c91"),
							common.HexToHash("0x00000000000000000000000081b12c1c6f6719c429648c531395c308a039b7d2"),
						},
						Data: hexutil.MustDecode("0x9e5034eacae74053ada43cfebb522c2ae6e5ffa4f3327e35cf46ae772decfbc2"),
					},
				},
			},
			Expected: []*Exchange{},
		},

		{
			Name: "extractValidOrdersByExchange_failed",
			Tx: &xycommon.RpcTransaction{
				Events: []xycommon.RpcLog{
					{
						Address: common.HexToAddress("0x24e24277e2FF8828d5d2e278764CA258C22BD497"),
						Topics: []common.Hash{
							common.HexToHash("0x3efe873bf4d1c1061b9980e7aed9b564e024844522ec8c80aec160809948ef77"),
						},
						Data: hexutil.MustDecode("0x00000000000000000000000023b2a8e35deea93139abc2791e895c65e1aa4c9100000000000000000000000081b12c1c6f6719c429648c531395c308a039b7d29e5034eacae74053ada43cfebb522c2ae6e5ffa4f3327e35cf46ae772decfbc20000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000019b45a4bb00000000000000000000000000000000000000000000000000000000251d94ea00000000000000000000000000000000000000000000000000000000000000c800000000000000000000000000000000000000000000000000000000659ce65300000000000000000000000000000000000000000000000000000000000000046176617600000000000000000000000000000000000000000000000000000000"),
					},
				},
			},
			Expected: []*Exchange{},
		},
	}

	cache := dcache.NewManager(nil, "avax")
	protocol := NewProtocol(cache)
	for _, test := range tests {
		t.Run(test.Name, func(t *testing.T) {
			result := protocol.extractValidOrdersByExchange(test.Tx)
			assert.Equal(t, len(result), len(test.Expected))
			if len(result) == len(test.Expected) {
				for idx, item := range result {
					assert.Equal(t, item.Tick, test.Expected[idx].Tick)
					assert.Equal(t, item.From, test.Expected[idx].From)
					assert.Equal(t, item.To, test.Expected[idx].To)
					assert.Equal(t, item.Amount, test.Expected[idx].Amount)
					assert.Equal(t, item.Operate, test.Expected[idx].Operate)
				}
			}
		})
	}
}

func TestExtractValidOrdersByTransfer(t *testing.T) {
	tests := []struct {
		Name     string
		Tx       *xycommon.RpcTransaction
		Expected []*Exchange
		Tickers  []string
	}{
		{
			Name:    "extractValidOrdersByTransfers",
			Tickers: []string{"avax"},
			Tx: &xycommon.RpcTransaction{
				Events: []xycommon.RpcLog{
					{
						Address: common.BytesToAddress([]byte("0x24e24277e2FF8828d5d2e278764CA258C22BD497")),
						Topics: []common.Hash{
							common.HexToHash("0x8cdf9e10a7b20e7a9c4e778fc3eb28f2766e438a9856a62eac39fbd2be98cbc2"),
							common.HexToHash("0x000000000000000000000000c37c800260cd7b766bf870d930a696b98259c546"),
							common.HexToHash("0x000000000000000000000000117b15af63e1d533cc5bac7333f3cc8f8cc2696d"),
							common.HexToHash("0x51ae1b9bb3103c91be3c12db9f97165657aee56ce412966fd68b8715b0481595"),
						},
						Data: hexutil.MustDecode("0x00000000000000000000000000000000000000000000000000000000000001f4"),
					},
				},
			},
			Expected: []*Exchange{
				{
					Tick:   "avax",
					From:   "0xC37C800260cd7B766bf870d930a696b98259C546",
					To:     "0x117b15af63E1D533cc5baC7333f3Cc8f8Cc2696d",
					Amount: decimal.NewFromInt(500),
				},
			},
		},
	}

	cache := dcache.NewManager(nil, "avax")
	cache.Inscription = dcache.NewInscription()
	protocol := NewProtocol(cache)
	for _, test := range tests {
		t.Run(test.Name, func(t *testing.T) {
			for _, tick := range test.Tickers {
				cache.Inscription.Create("asc-20", tick, &dcache.Tick{})
			}

			result := protocol.extractValidOrdersByTransfer(test.Tx)
			assert.Equal(t, len(result), len(test.Expected))
			if len(result) == len(test.Expected) {
				for idx, item := range result {
					assert.Equal(t, item.Tick, test.Expected[idx].Tick)
					assert.Equal(t, item.From, test.Expected[idx].From)
					assert.Equal(t, item.To, test.Expected[idx].To)
					assert.Equal(t, item.Amount, test.Expected[idx].Amount)
				}
			}
		})
	}
}
